// This file was generated by make generate
use crate::pkm::util;
use crate::pkm::strings::GbString;
use crate::pkm::types::StatsPreSplit;
use crate::pkm::util::to_sized_array;
use serde::Serialize;
use super::pkm::Pkm;

#[derive(Debug, Default, Serialize)]
pub struct PK1 {
  pub dex_num: u8,
  pub current_hp: u16,
  pub level: u8,
  pub status_condition: u8,
  pub type1: u8,
  pub type2: u8,
  pub held_item_index: u8,
  pub moves: [u8; 4],
  pub trainer_id: u16,
  pub evs_g12: StatsPreSplit,
  pub dvs: StatsPreSplit,
  pub move_pp: [u8; 4],
  pub move_pp_ups: [u8; 4],
  pub trainer_name: GbString<8>,
  pub nickname: GbString<11>,
}

impl Pkm<33, 66> for PK1 {
    const BOX_SIZE: usize = 33;
    const PARTY_SIZE: usize = 66;

	fn from_bytes(bytes: &[u8]) -> Result<Self, String> {
		let size = bytes.len();
		if size < 33 {
			return Err(format!(
				"byte array is too short for PK1 format (received {size}, expected >= 33)"
			));
		}
		let mon = PK1 {
			dex_num: bytes[0],
			current_hp: u16::from_be_bytes(to_sized_array(&bytes[1..3])),
			level: bytes[3],
			status_condition: bytes[4],
			type1: bytes[5],
			type2: bytes[6],
			held_item_index: bytes[7],
			moves: [bytes[8], bytes[9], bytes[10], bytes[11]],
			trainer_id: u16::from_be_bytes(to_sized_array(&bytes[12..14])),
			evs_g12: StatsPreSplit::from_bytes_be(to_sized_array(&bytes[17..27])),
			dvs: StatsPreSplit::from_dv_bytes(to_sized_array(&bytes[27..29])),
			move_pp: [util::int_from_buffer_bits_be::<u8>(bytes, 29, 0, 6).map_err(|e| format!("read field 'move_pp[0]': {e}"))?, util::int_from_buffer_bits_be::<u8>(bytes, 30, 6, 6).map_err(|e| format!("read field 'move_pp[1]': {e}"))?, util::int_from_buffer_bits_be::<u8>(bytes, 31, 12, 6).map_err(|e| format!("read field 'move_pp[2]': {e}"))?, util::int_from_buffer_bits_be::<u8>(bytes, 32, 18, 6).map_err(|e| format!("read field 'move_pp[3]': {e}"))?],
			move_pp_ups: [util::int_from_buffer_bits_be::<u8>(bytes, 29, 6, 2).map_err(|e| format!("read field 'move_pp_ups[0]': {e}"))?, util::int_from_buffer_bits_be::<u8>(bytes, 30, 8, 2).map_err(|e| format!("read field 'move_pp_ups[1]': {e}"))?, util::int_from_buffer_bits_be::<u8>(bytes, 31, 10, 2).map_err(|e| format!("read field 'move_pp_ups[2]': {e}"))?, util::int_from_buffer_bits_be::<u8>(bytes, 32, 12, 2).map_err(|e| format!("read field 'move_pp_ups[3]': {e}"))?],
			trainer_name: if bytes.len() > 66 { GbString::from_bytes(to_sized_array::<[u8; 8], u8>(&bytes[44..52])) } else { "TRAINER".into() },
			nickname: if bytes.len() > 66 { GbString::from_bytes(to_sized_array::<[u8; 11], u8>(&bytes[55..66])) } else { "NICKNAME".into() },
		};
		Ok(mon)
	}
	
	fn write_bytes(&self, bytes: &mut [u8; 33]) {
		
				
				bytes[1..3].copy_from_slice(&self.current_hp.to_be_bytes());
				bytes[3] = self.level;
				bytes[4] = self.status_condition;
				bytes[5] = self.type1;
				bytes[6] = self.type2;
				bytes[7] = self.held_item_index;
				
				bytes[12..14].copy_from_slice(&self.trainer_id.to_be_bytes());
				
				
				
				
				
				
	}
	
  	fn to_box_bytes(&self) -> [u8; 33] {
        let mut bytes = [0; 33];
		self.write_bytes(&mut bytes);

        bytes
	}
	
  	fn to_party_bytes(&self) -> [u8; 66] {
        let mut bytes = [0; 66];
		let box_slice: &mut [u8; 33] = bytes[0..33].as_mut().try_into().unwrap();
		self.write_bytes(box_slice);

		
				
				
				
				
				
				
				
				
				
				
				
				
				
				bytes[44..52].copy_from_slice(self.trainer_name.bytes().as_ref());
				bytes[55..66].copy_from_slice(self.nickname.bytes().as_ref());

        bytes
	}
}
