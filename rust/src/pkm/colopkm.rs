// This file was generated by make generate
use super::pkm::Pkm;
use crate::pkm::types::{ContestStats, FlagSet, Gender, Stats};
use crate::pkm::util::to_sized_array;
use crate::pkm::{strings, util};
use serde::Serialize;

#[derive(Debug, Default, Serialize)]
pub struct COLOPKM {
    pub dex_num: u16,
    pub personality_value: u32,
    pub game_of_origin: u8,
    pub language_index: u8,
    pub met_location_index: u16,
    pub met_level: u8,
    pub ball: u8,
    pub trainer_gender: Gender,
    pub trainer_id: u16,
    pub secret_id: u16,
    pub trainer_name: String,
    pub nickname: String,
    pub ribbon_bytes: FlagSet<4>,
    pub exp: u32,
    pub stat_level: u8,
    pub moves: [u16; 4],
    pub move_pp: [u8; 4],
    pub move_pp_ups: [u8; 4],
    pub held_item_index: u16,
    pub current_hp: u16,
    pub evs: Stats,
    pub ivs: Stats,
    pub contest: ContestStats,
    pub is_fateful_encounter: bool,
    pub pokerus_byte: u8,
    pub trainer_friendship: u8,
    pub shadow_id: u16,
    pub shadow_gauge: u32,
}

impl Pkm<312, 312> for COLOPKM {
    const BOX_SIZE: usize = 312;
    const PARTY_SIZE: usize = 312;

    fn from_bytes(bytes: &[u8]) -> Result<Self, String> {
        let size = bytes.len();
        if size < 312 {
            return Err(format!(
                "byte array is too short for COLOPKM format (received {size}, expected >= 312)"
            ));
        }
        let mon = COLOPKM {
            dex_num: u16::from_be_bytes(to_sized_array(&bytes[0..2])),
            personality_value: u32::from_be_bytes(to_sized_array(&bytes[4..8])),
            game_of_origin: bytes[8],
            language_index: bytes[11],
            met_location_index: u16::from_be_bytes(to_sized_array(&bytes[12..14])),
            met_level: bytes[14],
            ball: bytes[15],
            trainer_gender: util::get_flag(bytes, 16, 1).into(),
            trainer_id: u16::from_be_bytes(to_sized_array(&bytes[20..22])),
            secret_id: u16::from_be_bytes(to_sized_array(&bytes[22..24])),
            trainer_name: strings::utf16::from_be_bytes(bytes[24..46].to_vec()),
            nickname: strings::utf16::from_be_bytes(bytes[46..68].to_vec()),
            ribbon_bytes: FlagSet::from_bytes(to_sized_array(&bytes[76..80])),
            exp: u32::from_be_bytes(to_sized_array(&bytes[92..96])),
            stat_level: bytes[96],
            moves: [
                u16::from_be_bytes(to_sized_array(&bytes[120..122])),
                u16::from_be_bytes(to_sized_array(&bytes[122..124])),
                u16::from_be_bytes(to_sized_array(&bytes[124..126])),
                u16::from_be_bytes(to_sized_array(&bytes[126..128])),
            ],
            move_pp: [bytes[122], bytes[123], bytes[124], bytes[125]],
            move_pp_ups: [bytes[123], bytes[124], bytes[125], bytes[126]],
            held_item_index: u16::from_be_bytes(to_sized_array(&bytes[136..138])),
            current_hp: u16::from_be_bytes(to_sized_array(&bytes[138..140])),
            evs: Stats::from_bytes(to_sized_array(&bytes[153..159])),
            ivs: Stats::from_bytes(to_sized_array(&bytes[165..171])),
            contest: ContestStats::from_bytes(to_sized_array(&bytes[178..184])),
            is_fateful_encounter: util::get_flag(bytes, 201, 4),
            pokerus_byte: bytes[202],
            trainer_friendship: bytes[208],
            shadow_id: u16::from_be_bytes(to_sized_array(&bytes[216..218])),
            shadow_gauge: u32::from_be_bytes(to_sized_array(&bytes[220..224])),
        };
        Ok(mon)
    }

    fn write_bytes(&self, bytes: &mut [u8; 312]) {
        bytes[0..2].copy_from_slice(&self.dex_num.to_be_bytes());
        bytes[4..8].copy_from_slice(&self.personality_value.to_be_bytes());
        bytes[8] = self.game_of_origin;
        bytes[11] = self.language_index;
        bytes[12..14].copy_from_slice(&self.met_location_index.to_be_bytes());
        bytes[14] = self.met_level;
        bytes[15] = self.ball;

        bytes[20..22].copy_from_slice(&self.trainer_id.to_be_bytes());
        bytes[22..24].copy_from_slice(&self.secret_id.to_be_bytes());
        bytes[24..35].copy_from_slice(&strings::utf16::to_be_bytes(&self.trainer_name));
        bytes[46..57].copy_from_slice(&strings::utf16::to_be_bytes(&self.nickname));

        bytes[92..96].copy_from_slice(&self.exp.to_be_bytes());
        bytes[96] = self.stat_level;

        bytes[136..138].copy_from_slice(&self.held_item_index.to_be_bytes());
        bytes[138..140].copy_from_slice(&self.current_hp.to_be_bytes());
        bytes[153..159].copy_from_slice(&self.evs.to_bytes());
        bytes[165..171].copy_from_slice(&self.ivs.to_bytes());
        bytes[178..184].copy_from_slice(&self.contest.to_bytes());

        bytes[202] = self.pokerus_byte;
        bytes[208] = self.trainer_friendship;
        bytes[216..218].copy_from_slice(&self.shadow_id.to_be_bytes());
        bytes[220..224].copy_from_slice(&self.shadow_gauge.to_be_bytes());
    }

    fn to_box_bytes(&self) -> [u8; 312] {
        let mut bytes = [0; 312];
        self.write_bytes(&mut bytes);

        bytes
    }

    fn to_party_bytes(&self) -> [u8; 312] {
        let mut bytes = [0; 312];
        let box_slice: &mut [u8; 312] = bytes[0..312].as_mut().try_into().unwrap();
        self.write_bytes(box_slice);

        bytes
    }
}
