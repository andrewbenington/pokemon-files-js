// This file was generated by make generate
use super::pkm::Pkm;
use crate::pkm::types::{Gender, Stats};
use crate::pkm::util::to_sized_array;
use crate::pkm::{strings, util};
use serde::Serialize;

#[derive(Debug, Default, Serialize)]
pub struct PB7 {
    pub encryption_constant: u32,
    pub dex_num: u16,
    pub held_item_index: u16,
    pub trainer_id: u16,
    pub secret_id: u16,
    pub exp: u32,
    pub ability_index: u8,
    pub ability_num: u8,
    pub favorite: bool,
    pub personality_value: u32,
    pub nature: u8,
    pub is_fateful_encounter: bool,
    pub gender: Gender,
    pub forme_num: u8,
    pub evs: Stats,
    pub avs: Stats,
    pub resort_event_status: u8,
    pub pokerus_byte: u8,
    pub height: u8,
    pub weight: u8,
    pub form_argument: u32,
    pub nickname: String,
    pub moves: [u16; 4],
    pub move_pp: [u8; 4],
    pub move_pp_ups: [u8; 4],
    pub relearn_moves: [u16; 4],
    pub ivs: Stats,
    pub is_egg: bool,
    pub is_nicknamed: bool,
    pub handler_name: String,
    pub handler_gender: bool,
    pub is_current_handler: bool,
    pub handler_friendship: u8,
    pub field_event_fatigue1: u8,
    pub field_event_fatigue2: u8,
    pub fullness: u8,
    pub enjoyment: u8,
    pub trainer_name: String,
    pub trainer_friendship: u8,
    pub egg_location_index: u16,
    pub met_location_index: u16,
    pub ball: u8,
    pub met_level: u8,
    pub hyper_training: Stats,
    pub game_of_origin: u8,
    pub language_index: u8,
    pub status_condition: u8,
    pub current_hp: u8,
    pub trainer_gender: Gender,
}

impl Pkm<232, 260> for PB7 {
    const BOX_SIZE: usize = 232;
    const PARTY_SIZE: usize = 260;

    fn from_bytes(bytes: &[u8]) -> Result<Self, String> {
        let size = bytes.len();
        if size < 232 {
            return Err(format!(
                "byte array is too short for PB7 format (received {size}, expected >= 232)"
            ));
        }
        let mon = PB7 {
            encryption_constant: u32::from_le_bytes(to_sized_array(&bytes[0..4])),
            dex_num: u16::from_le_bytes(to_sized_array(&bytes[8..10])),
            held_item_index: u16::from_le_bytes(to_sized_array(&bytes[10..12])),
            trainer_id: u16::from_le_bytes(to_sized_array(&bytes[12..14])),
            secret_id: u16::from_le_bytes(to_sized_array(&bytes[14..16])),
            exp: u32::from_le_bytes(to_sized_array(&bytes[16..20])),
            ability_index: bytes[20],
            ability_num: bytes[21],
            favorite: util::get_flag(bytes, 21, 3),
            personality_value: u32::from_le_bytes(to_sized_array(&bytes[24..28])),
            nature: bytes[28],
            is_fateful_encounter: util::get_flag(bytes, 29, 0),
            gender: util::int_from_buffer_bits_le::<u8>(bytes, 29, 1, 2)
                .map_err(|e| format!("read field 'gender': {e}"))?
                .into(),
            forme_num: util::int_from_buffer_bits_le::<u8>(bytes, 29, 3, 5)
                .map_err(|e| format!("read field 'forme_num': {e}"))?,
            evs: Stats::from_bytes(to_sized_array(&bytes[30..36])),
            avs: Stats::from_bytes(to_sized_array(&bytes[36..42])),
            resort_event_status: bytes[42],
            pokerus_byte: bytes[43],
            height: bytes[58],
            weight: bytes[59],
            form_argument: u32::from_le_bytes(to_sized_array(&bytes[60..64])),
            nickname: strings::utf16::from_be_bytes(bytes[64..88].to_vec()),
            moves: [
                u16::from_le_bytes(to_sized_array(&bytes[90..92])),
                u16::from_le_bytes(to_sized_array(&bytes[92..94])),
                u16::from_le_bytes(to_sized_array(&bytes[94..96])),
                u16::from_le_bytes(to_sized_array(&bytes[96..98])),
            ],
            move_pp: [bytes[98], bytes[99], bytes[100], bytes[101]],
            move_pp_ups: [bytes[102], bytes[103], bytes[104], bytes[105]],
            relearn_moves: [
                u16::from_le_bytes(to_sized_array(&bytes[106..108])),
                u16::from_le_bytes(to_sized_array(&bytes[108..110])),
                u16::from_le_bytes(to_sized_array(&bytes[110..112])),
                u16::from_le_bytes(to_sized_array(&bytes[112..114])),
            ],
            ivs: Stats::from_30_bits(to_sized_array(&bytes[116..120])),
            is_egg: util::get_flag(bytes, 116, 30),
            is_nicknamed: util::get_flag(bytes, 116, 31),
            handler_name: strings::utf16::from_be_bytes(bytes[120..144].to_vec()),
            handler_gender: util::get_flag(bytes, 146, 0),
            is_current_handler: util::get_flag(bytes, 147, 0),
            handler_friendship: bytes[162],
            field_event_fatigue1: bytes[172],
            field_event_fatigue2: bytes[173],
            fullness: bytes[174],
            enjoyment: bytes[175],
            trainer_name: strings::utf16::from_be_bytes(bytes[176..200].to_vec()),
            trainer_friendship: bytes[202],
            egg_location_index: u16::from_le_bytes(to_sized_array(&bytes[216..218])),
            met_location_index: u16::from_le_bytes(to_sized_array(&bytes[218..220])),
            ball: bytes[220],
            met_level: bytes[221],
            hyper_training: Stats::from_hyper_train_bytes(to_sized_array(&bytes[222..228])),
            game_of_origin: bytes[223],
            language_index: bytes[227],
            status_condition: if bytes.len() > 260 { bytes[232] } else { 0 },
            current_hp: if bytes.len() > 260 { bytes[240] } else { 0 },
            trainer_gender: util::get_flag(bytes, 221, 7).into(),
        };
        Ok(mon)
    }

    fn write_bytes(&self, bytes: &mut [u8; 232]) {
        bytes[0..4].copy_from_slice(&self.encryption_constant.to_le_bytes());
        bytes[8..10].copy_from_slice(&self.dex_num.to_le_bytes());
        bytes[10..12].copy_from_slice(&self.held_item_index.to_le_bytes());
        bytes[12..14].copy_from_slice(&self.trainer_id.to_le_bytes());
        bytes[14..16].copy_from_slice(&self.secret_id.to_le_bytes());
        bytes[16..20].copy_from_slice(&self.exp.to_le_bytes());
        bytes[20] = self.ability_index;
        bytes[21] = self.ability_num;

        bytes[24..28].copy_from_slice(&self.personality_value.to_le_bytes());
        bytes[28] = self.nature;

        bytes[29] = self.gender.into();
        bytes[29] = self.forme_num;

        bytes[42] = self.resort_event_status;
        bytes[43] = self.pokerus_byte;
        bytes[58] = self.height;
        bytes[59] = self.weight;
        bytes[60..64].copy_from_slice(&self.form_argument.to_le_bytes());
        bytes[64..76].copy_from_slice(&strings::utf16::to_be_bytes(&self.nickname));

        bytes[120..132].copy_from_slice(&strings::utf16::to_be_bytes(&self.handler_name));

        bytes[162] = self.handler_friendship;
        bytes[172] = self.field_event_fatigue1;
        bytes[173] = self.field_event_fatigue2;
        bytes[174] = self.fullness;
        bytes[175] = self.enjoyment;
        bytes[176..188].copy_from_slice(&strings::utf16::to_be_bytes(&self.trainer_name));
        bytes[202] = self.trainer_friendship;
        bytes[216..218].copy_from_slice(&self.egg_location_index.to_le_bytes());
        bytes[218..220].copy_from_slice(&self.met_location_index.to_le_bytes());
        bytes[220] = self.ball;
        bytes[221] = self.met_level;

        bytes[223] = self.game_of_origin;
        bytes[227] = self.language_index;
    }

    fn to_box_bytes(&self) -> [u8; 232] {
        let mut bytes = [0; 232];
        self.write_bytes(&mut bytes);

        bytes
    }

    fn to_party_bytes(&self) -> [u8; 260] {
        let mut bytes = [0; 260];
        let box_slice: &mut [u8; 232] = bytes[0..232].as_mut().try_into().unwrap();
        self.write_bytes(box_slice);

        bytes[232] = self.status_condition;
        bytes[240] = self.current_hp;

        bytes
    }
}
