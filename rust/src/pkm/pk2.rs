// This file was generated by make generate
use crate::pkm::util;
use crate::pkm::strings::GbString;
use crate::pkm::types::{StatsPreSplit, Gender};
use crate::pkm::util::to_sized_array;
use serde::Serialize;
use super::pkm::Pkm;

#[derive(Debug, Default, Serialize)]
pub struct PK2 {
  pub dex_num: u8,
  pub held_item_index: u8,
  pub moves: [u8; 4],
  pub trainer_id: u16,
  pub evs_g12: StatsPreSplit,
  pub dvs: StatsPreSplit,
  pub move_pp: [u8; 4],
  pub move_pp_ups: [u8; 4],
  pub trainer_friendship: u8,
  pub pokerus_byte: u8,
  pub met_time_of_day: u8,
  pub met_level: u8,
  pub met_location_index: u8,
  pub level: u8,
  pub status_condition: u8,
  pub current_hp: u8,
  pub trainer_name: GbString<8>,
  pub nickname: GbString<11>,
  pub trainer_gender: Gender,
}

impl Pkm<32, 73> for PK2 {
    const BOX_SIZE: usize = 32;
    const PARTY_SIZE: usize = 73;

	fn from_bytes(bytes: &[u8]) -> Result<Self, String> {
		let size = bytes.len();
		if size < 32 {
			return Err(format!(
				"byte array is too short for PK2 format (received {size}, expected >= 32)"
			));
		}
		let mon = PK2 {
			dex_num: bytes[0],
			held_item_index: bytes[1],
			moves: [bytes[2], bytes[3], bytes[4], bytes[5]],
			trainer_id: u16::from_be_bytes(to_sized_array(&bytes[6..8])),
			evs_g12: StatsPreSplit::from_bytes_be(to_sized_array(&bytes[11..21])),
			dvs: StatsPreSplit::from_dv_bytes(to_sized_array(&bytes[21..23])),
			move_pp: [util::int_from_buffer_bits_be::<u8>(bytes, 23, 0, 6).map_err(|e| format!("read field 'move_pp[0]': {e}"))?, util::int_from_buffer_bits_be::<u8>(bytes, 24, 6, 6).map_err(|e| format!("read field 'move_pp[1]': {e}"))?, util::int_from_buffer_bits_be::<u8>(bytes, 25, 12, 6).map_err(|e| format!("read field 'move_pp[2]': {e}"))?, util::int_from_buffer_bits_be::<u8>(bytes, 26, 18, 6).map_err(|e| format!("read field 'move_pp[3]': {e}"))?],
			move_pp_ups: [util::int_from_buffer_bits_be::<u8>(bytes, 23, 6, 2).map_err(|e| format!("read field 'move_pp_ups[0]': {e}"))?, util::int_from_buffer_bits_be::<u8>(bytes, 24, 8, 2).map_err(|e| format!("read field 'move_pp_ups[1]': {e}"))?, util::int_from_buffer_bits_be::<u8>(bytes, 25, 10, 2).map_err(|e| format!("read field 'move_pp_ups[2]': {e}"))?, util::int_from_buffer_bits_be::<u8>(bytes, 26, 12, 2).map_err(|e| format!("read field 'move_pp_ups[3]': {e}"))?],
			trainer_friendship: bytes[27],
			pokerus_byte: bytes[28],
			met_time_of_day: util::int_from_buffer_bits_be::<u8>(bytes, 29, 6, 2).map_err(|e| format!("read field 'met_time_of_day': {e}"))?,
			met_level: util::int_from_buffer_bits_be::<u8>(bytes, 29, 0, 6).map_err(|e| format!("read field 'met_level': {e}"))?,
			met_location_index: util::int_from_buffer_bits_be::<u8>(bytes, 30, 0, 7).map_err(|e| format!("read field 'met_location_index': {e}"))?,
			level: bytes[31],
			status_condition: if bytes.len() > 70 { bytes[32] } else { 0 },
			current_hp: if bytes.len() > 70 { bytes[34] } else { 0 },
			trainer_name: if bytes.len() > 70 { GbString::from_bytes(to_sized_array::<[u8; 8], u8>(&bytes[48..56])) } else { "TRAINER".into() },
			nickname: if bytes.len() > 70 { GbString::from_bytes(to_sized_array::<[u8; 11], u8>(&bytes[59..70])) } else { "NICKNAME".into() },
			trainer_gender: util::get_flag(bytes, 30, 7).into(),
		};
		Ok(mon)
	}
	
	fn write_bytes(&self, bytes: &mut [u8; 32]) {
		
				bytes[0] = self.dex_num;
				bytes[1] = self.held_item_index;
				
				bytes[6..8].copy_from_slice(&self.trainer_id.to_be_bytes());
				
				
				
				
				bytes[27] = self.trainer_friendship;
				bytes[28] = self.pokerus_byte;
				bytes[29] = self.met_time_of_day;
				bytes[29] = self.met_level;
				bytes[30] = self.met_location_index;
				bytes[31] = self.level;
				
				
				
				
				
	}
	
  	fn to_box_bytes(&self) -> [u8; 32] {
        let mut bytes = [0; 32];
		self.write_bytes(&mut bytes);

        bytes
	}
	
  	fn to_party_bytes(&self) -> [u8; 73] {
        let mut bytes = [0; 73];
		let box_slice: &mut [u8; 32] = bytes[0..32].as_mut().try_into().unwrap();
		self.write_bytes(box_slice);

		
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				bytes[32] = self.status_condition;
				bytes[34] = self.current_hp;
				bytes[48..56].copy_from_slice(self.trainer_name.bytes().as_ref());
				bytes[59..70].copy_from_slice(self.nickname.bytes().as_ref());
				

        bytes
	}
}
