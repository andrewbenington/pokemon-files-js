// This file was generated by make generate
use crate::pkm::util;
use crate::pkm::strings::Gen3String;
use crate::pkm::types::{Stats, ContestStats, Gender};
use crate::pkm::util::to_sized_array;
use serde::Serialize;
use super::pkm::Pkm;

#[derive(Debug, Default, Serialize)]
pub struct PK3 {
  pub personality_value: u32,
  pub trainer_id: u16,
  pub secret_id: u16,
  pub language_index: u8,
  pub dex_num: u16,
  pub held_item_index: u16,
  pub exp: u32,
  pub move_pp_ups: [u8; 4],
  pub trainer_friendship: u8,
  pub moves: [u16; 4],
  pub move_pp: [u8; 4],
  pub evs: Stats,
  pub contest: ContestStats,
  pub pokerus_byte: u8,
  pub met_location_index: u8,
  pub met_level: u8,
  pub game_of_origin: u8,
  pub ball: u8,
  pub ivs: Stats,
  pub is_egg: bool,
  pub is_nicknamed: bool,
  pub ribbon_bytes: [u8; 4],
  pub is_fateful_encounter: bool,
  pub status_condition: u8,
  pub current_hp: u8,
  pub nickname: Gen3String<10>,
  pub trainer_name: Gen3String<7>,
  pub trainer_gender: Gender,
  pub checksum: u16,
}

impl Pkm<80, 100> for PK3 {
    const BOX_SIZE: usize = 80;
    const PARTY_SIZE: usize = 100;

	fn from_bytes(bytes: &[u8]) -> Result<Self, String> {
		let size = bytes.len();
		if size < 80 {
			return Err(format!(
				"byte array is too short for PK3 format (received {size}, expected >= 80)"
			));
		}
		let mon = PK3 {
			personality_value: u32::from_le_bytes(to_sized_array(&bytes[0..4])),
			trainer_id: u16::from_le_bytes(to_sized_array(&bytes[4..6])),
			secret_id: u16::from_le_bytes(to_sized_array(&bytes[6..8])),
			language_index: bytes[18],
			dex_num: u16::from_le_bytes(to_sized_array(&bytes[32..34])),
			held_item_index: u16::from_le_bytes(to_sized_array(&bytes[34..36])),
			exp: u32::from_le_bytes(to_sized_array(&bytes[36..40])),
			move_pp_ups: [util::int_from_buffer_bits_le::<u8>(bytes, 40, 0, 2).map_err(|e| format!("read field 'move_pp_ups[0]': {e}"))?, util::int_from_buffer_bits_le::<u8>(bytes, 40, 0, 2).map_err(|e| format!("read field 'move_pp_ups[1]': {e}"))?, util::int_from_buffer_bits_le::<u8>(bytes, 40, 0, 2).map_err(|e| format!("read field 'move_pp_ups[2]': {e}"))?, util::int_from_buffer_bits_le::<u8>(bytes, 40, 0, 2).map_err(|e| format!("read field 'move_pp_ups[3]': {e}"))?],
			trainer_friendship: bytes[41],
			moves: [u16::from_le_bytes(to_sized_array(&bytes[44..46])), u16::from_le_bytes(to_sized_array(&bytes[46..48])), u16::from_le_bytes(to_sized_array(&bytes[48..50])), u16::from_le_bytes(to_sized_array(&bytes[50..52]))],
			move_pp: [bytes[52], bytes[53], bytes[54], bytes[55]],
			evs: Stats::from_bytes(to_sized_array(&bytes[56..62])),
			contest: ContestStats::from_bytes(to_sized_array(&bytes[62..68])),
			pokerus_byte: bytes[68],
			met_location_index: bytes[69],
			met_level: util::int_from_buffer_bits_le::<u8>(bytes, 70, 0, 7).map_err(|e| format!("read field 'met_level': {e}"))?,
			game_of_origin: util::int_from_buffer_bits_le::<u8>(bytes, 70, 7, 4).map_err(|e| format!("read field 'game_of_origin': {e}"))?,
			ball: util::int_from_buffer_bits_le::<u8>(bytes, 70, 11, 4).map_err(|e| format!("read field 'ball': {e}"))?,
			ivs: Stats::from_30_bits(to_sized_array(&bytes[72..76])),
			is_egg: util::get_flag(bytes, 72, 30),
			is_nicknamed: util::get_flag(bytes, 72, 31),
			ribbon_bytes: to_sized_array(&bytes[76..80]),
			is_fateful_encounter: util::get_flag(bytes, 76, 31),
			status_condition: if bytes.len() > 100 { bytes[80] } else { 0 },
			current_hp: if bytes.len() > 100 { bytes[86] } else { 0 },
			nickname: Gen3String::from_bytes(to_sized_array::<[u8; 10], u8>(&bytes[8..18])),
			trainer_name: Gen3String::from_bytes(to_sized_array::<[u8; 7], u8>(&bytes[20..27])),
			trainer_gender: util::get_flag(bytes, 70, 15).into(),
			checksum: u16::from_le_bytes(to_sized_array(&bytes[28..30])),
		};
		Ok(mon)
	}
	
	fn write_bytes(&self, bytes: &mut [u8; 80]) {
		
				bytes[0..4].copy_from_slice(&self.personality_value.to_le_bytes());
				bytes[4..6].copy_from_slice(&self.trainer_id.to_le_bytes());
				bytes[6..8].copy_from_slice(&self.secret_id.to_le_bytes());
				bytes[18] = self.language_index;
				
				bytes[34..36].copy_from_slice(&self.held_item_index.to_le_bytes());
				bytes[36..40].copy_from_slice(&self.exp.to_le_bytes());
				
				bytes[41] = self.trainer_friendship;
				
				
				bytes[56..62].copy_from_slice(&self.evs.to_bytes());
				bytes[62..68].copy_from_slice(&self.contest.to_bytes());
				bytes[68] = self.pokerus_byte;
				bytes[69] = self.met_location_index;
				bytes[70] = self.met_level;
				bytes[70] = self.game_of_origin;
				bytes[70] = self.ball;
				
				
				
				
				
				
				
				bytes[8..18].copy_from_slice(self.nickname.bytes().as_ref());
				bytes[20..27].copy_from_slice(self.trainer_name.bytes().as_ref());
				
				bytes[28..30].copy_from_slice(&self.checksum.to_le_bytes());
	}
	
  	fn to_box_bytes(&self) -> [u8; 80] {
        let mut bytes = [0; 80];
		self.write_bytes(&mut bytes);

        bytes
	}
	
  	fn to_party_bytes(&self) -> [u8; 100] {
        let mut bytes = [0; 100];
		let box_slice: &mut [u8; 80] = bytes[0..80].as_mut().try_into().unwrap();
		self.write_bytes(box_slice);

		
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				
				bytes[80] = self.status_condition;
				bytes[86] = self.current_hp;
				
				
				
				

        bytes
	}
}
