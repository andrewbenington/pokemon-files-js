package rust

import (
	"encoding/json"
	"fmt"
	"os"
	"text/template"

	"github.com/andrewbenington/go-pokemon-files/gen/schema"
)

const rustClassTemplate = `// This file was generated by make generate
{{- $structName := .SchemaData.FileName }}
{{- $encoding := .SchemaData.StringEncoding}}
{{- $endian := .SchemaData.Endian}}
{{- $detectPrefix := .SchemaData.DetectPrefix}}
{{- $schema := .SchemaData}}
{{- range $namespace, $import := .ImportsByNamespace }}
{{ $import.GetUseString }}
{{- end }}

#[derive(Debug, Default, Serialize)]
pub struct {{ $structName }} {
{{- range .Fields }}
  {{ .Name }}: {{ .RustType }},
{{- end }}
}

impl {{ $structName }} {
  pub fn from_bytes(bytes: Vec<u8>) -> Result<Self, Box<dyn std::error::Error>> {
	{{- range $field := .Fields }}
	{{ assignFieldToVarFromBytes $field $schema }}
	{{- end }}
    let mon = {{ $structName }} {
      {{- range $field := .Fields }}
        {{ .Name }},
      {{- end }}
    };
	return Ok(mon);
  }
}
`

func generateFormatClass(format string) {
	// Read the content of the file
	data, err := os.ReadFile(fmt.Sprintf("src/schema/%s.json", format))
	if err != nil {
		fmt.Println("Error reading file:", err)
		return
	}

	rsFileData := RustSchemaData{
		SchemaData: schema.SchemaData{},
		Fields:     []RustField{},
	}
	// rsFileData.AddImport("pokemon-resources", "Languages")
	// rsFileData.AddImport("../util/util", "adjustMovePPBetweenFormats")

	json.Unmarshal(data, &rsFileData.SchemaData)
	rsFileData.AddImport("serde", "Serialize")
	rsFileData.AddImport("crate::pkm", "util")
	rsFileData.AddImport("crate::pkm::util", "to_sized_array")
	rsFileData.AddImport("crate::pkm", "strings")

	// if rsFileData.SchemaData.NatureFromPV {
	// 	rsFileData.AddImport("pokemon-resources", "NatureToString")
	// }
	// if rsFileData.SchemaData.UnownFromIVs || rsFileData.SchemaData.UnownFromPV {
	// 	rsFileData.AddImport("pokemon-species-data", "NationalDex")
	// }
	// if rsFileData.SchemaData.TrainerIDTracker {
	// 	rsFileData.AddImport("pokemon-resources", "isGameBoy")
	// }

	for _, field := range rsFileData.SchemaData.Fields {
		rField, err := RustFieldFromSchemaField(field)
		if err != nil {
			fmt.Printf("%s: skipping %s (%s)\n", format, field.Name, err)
			continue
		}

		switch rField.RustType {
		case "StatsPreSplit":
			rsFileData.AddImport("crate::pkm::types", "StatsPreSplit")
		case "Stats":
			rsFileData.AddImport("crate::pkm::types", "Stats")
		}

		// Add necessary imports
		// switch rField.Field.Name {
		// case "ribbons":
		// 	rsFileData.AddImport("../util/ribbonLogic", "filterRibbons")
		// 	for _, ribbonSpan := range rField.Field.RibbonSpans {
		// 		if ribbonSpan.ContestCounts {
		// 			if ribbonSpan.NumBits != 40 {
		// 				rsFileData.AddImport("../util/ribbonLogic", "gen3ContestRibbonsFromBuffer")
		// 				rsFileData.AddImport("../util/ribbonLogic", "gen3ContestRibbonsToBuffer")
		// 			} else {
		// 				rsFileData.AddImport("../util/ribbonLogic", "gen3ContestRibbonsFromBytes")
		// 				rsFileData.AddImport("../util/ribbonLogic", "gen3ContestRibbonsToBytes")
		// 			}
		// 		}
		// 		rsFileData.AddImport("pokemon-resources", ribbonListFromName(ribbonSpan.RibbonSet))
		// 	}
		// case "abilityIndex":
		// 	rsFileData.AddImport("pokemon-resources", "AbilityToString")
		// case "heldItemIndex":
		// 	if rsFileData.SchemaData.IsGen3 {
		// 		rsFileData.AddImport("pokemon-resources", "ItemGen3ToString")
		// 		rsFileData.AddImport("pokemon-resources", "ItemGen3FromString")
		// 	} else {
		// 		rsFileData.AddImport("pokemon-resources", "ItemToString")
		// 		rsFileData.AddImport("pokemon-resources", "ItemFromString")
		// 	}
		// case "nature":
		// 	rsFileData.AddImport("pokemon-resources", "NatureToString")
		// case "nickname", "trainerName":
		// 	if rField.Field.LengthCheck > 0 || rsFileData.IsGen3 {
		// 		rsFileData.AddImport("pokemon-species-data", "PokemonData")
		// 	}
		// case "ball":
		// 	rsFileData.AddImport("pokemon-resources", "Ball")
		// }

		// if field.Conversion != nil {
		// 	rsFileData.AddDefaultImport("../conversion", "* as conversion")
		// }

		if rField.Field.ByteOffset != nil && *rField.Field.ByteOffset >= rsFileData.SchemaData.TotalBytes && field.LengthCheck == 0 {
			continue
		}

		rsFileData.Fields = append(rsFileData.Fields, *rField)
	}

	// Create the output file
	file, err := os.Create(fmt.Sprintf("rust/src/pkm/%s.rs", format))
	if err != nil {
		fmt.Println("Error creating output file:", err)
		return
	}
	defer file.Close()

	// isNotUniversal := func(fieldName string) bool {
	// 	return !universalFields[fieldName]
	// }

	// Create a template and execute it to generate the Go code
	tmpl := template.Must(template.New(format).Funcs(template.FuncMap{
		"fieldExists": fieldExists,
		// "fieldNullable":         isNotUniversal,
		// "setFieldFromOther":     setFieldFromOther,
		"commaJoinStrings":      commaJoinStrings,
		"getDecryptionFunction": getDecryptionFunction,
		"getUnshuffleFunction":  getUnshuffleFunction,
		"getShuffleFunction":    getShuffleFunction,
		"hexify":                hexify,
		"commaSeparateInts":     commaSeparate[int],
		// "writeFieldToBytes":     writeFieldToBytes,
		"assignFieldToVarFromBytes": assignFieldToVarFromBytes,
	}).Parse(rustClassTemplate))
	err = tmpl.Execute(file, rsFileData)
	if err != nil {
		fmt.Println("Error executing template:", err)
		return
	}

}
