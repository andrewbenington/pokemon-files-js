package rust

import (
	"encoding/json"
	"fmt"
	"os"
	"text/template"

	"github.com/andrewbenington/go-pokemon-files/gen/schema"
)

const rustClassTemplate = `// This file was generated by make generate
{{- $structName := .SchemaData.FileName }}
{{- $encoding := .SchemaData.StringEncoding}}
{{- $endian := .SchemaData.Endian}}
{{- $detectPrefix := .SchemaData.DetectPrefix}}
{{- $schema := .SchemaData}}
{{- range $namespace, $import := .ImportsByNamespace }}
{{ $import.GetUseString }}
{{- end }}

#[derive(Debug, Default, Serialize)]
pub struct {{ $structName }} {
{{- range .Fields }}
  pub {{ .Name }}: {{ .RustType }},
{{- end }}
}

impl Pkm<{{ .SchemaData.TotalBytes }}, {{ .SchemaData.TotalBytesExtraFields }}> for {{ $structName }} {
    const BOX_SIZE: usize = {{ .SchemaData.TotalBytes }};
    const PARTY_SIZE: usize = {{ .SchemaData.TotalBytesExtraFields }};

	fn from_bytes(bytes: &[u8]) -> Result<Self, String> {
		let size = bytes.len();
		if size < {{ .SchemaData.TotalBytes }} {
			return Err(format!(
				"byte array is too short for {{ $structName }} format (received {size}, expected >= {{ .SchemaData.TotalBytes }})"
			));
		}
		let mon = {{ $structName }} {
		{{- range $field := .Fields }}
			{{ .Name }}: {{ fieldValueFromBytes $field $schema }},
		{{- end }}
		};
		Ok(mon)
	}
	
	fn write_bytes(&self, bytes: &mut [u8; {{ .SchemaData.TotalBytes }}]) {
		{{ range $field := .Fields }}
			{{- if not $field.NoWrite }}
				{{ writeFieldToBytes $field $schema false }}
			{{- end }}
		{{- end }}
	}
	
  	fn to_box_bytes(&self) -> [u8; {{ .SchemaData.TotalBytes }}] {
        let mut bytes = [0; {{ .SchemaData.TotalBytes }}];
		self.write_bytes(&mut bytes);

        bytes
	}
	
  	fn to_party_bytes(&self) -> [u8; {{ .SchemaData.TotalBytesExtraFields }}] {
        let mut bytes = [0; {{ .SchemaData.TotalBytesExtraFields }}];
		let box_slice: &mut [u8; {{ .SchemaData.TotalBytes }}] = bytes[0..{{ .SchemaData.TotalBytes }}].as_mut().try_into().unwrap();
		self.write_bytes(box_slice);

		{{ range $field := .Fields }}
			{{- if not $field.NoWrite }}
				{{ writeFieldToBytes $field $schema true }}
			{{- end }}
		{{- end }}

        bytes
	}
}
`

func generateFormatClass(format string) {
	// Read the content of the file
	data, err := os.ReadFile(fmt.Sprintf("src/schema/%s.json", format))
	if err != nil {
		fmt.Println("Error reading file:", err)
		return
	}

	rsFileData := RustSchemaData{
		SchemaData: schema.SchemaData{},
		Fields:     []RustField{},
	}
	// rsFileData.AddImport("pokemon-resources", "Languages")
	// rsFileData.AddImport("../util/util", "adjustMovePPBetweenFormats")

	json.Unmarshal(data, &rsFileData.SchemaData)
	if rsFileData.TotalBytesExtraFields == 0 {
		rsFileData.TotalBytesExtraFields = rsFileData.TotalBytes
	}
	rsFileData.AddImport("super::pkm", "Pkm")
	rsFileData.AddImport("serde", "Serialize")
	rsFileData.AddImport("crate::pkm", "util")
	rsFileData.AddImport("crate::pkm::util", "to_sized_array")
	switch rsFileData.StringEncoding {
	case "GameBoy":
		rsFileData.AddImport("crate::pkm::strings", "GbString")
	case "Gen3":
		rsFileData.AddImport("crate::pkm::strings", "Gen3String")
	case "Gen4":
		rsFileData.AddImport("crate::pkm::strings", "Gen4String")
	case "Gen5":
		rsFileData.AddImport("crate::pkm::strings", "Gen5String")
	default:
		rsFileData.AddImport("crate::pkm", "strings")
	}

	// if rsFileData.SchemaData.NatureFromPV {
	// 	rsFileData.AddImport("pokemon-resources", "NatureToString")
	// }
	// if rsFileData.SchemaData.UnownFromIVs || rsFileData.SchemaData.UnownFromPV {
	// 	rsFileData.AddImport("pokemon-species-data", "NationalDex")
	// }
	// if rsFileData.SchemaData.TrainerIDTracker {
	// 	rsFileData.AddImport("pokemon-resources", "isGameBoy")
	// }

	for _, field := range rsFileData.SchemaData.Fields {
		rField, err := RustFieldFromSchemaField(field, rsFileData.StringEncoding)
		if err != nil {
			fmt.Printf("%s: skipping %s (%s)\n", format, field.Name, err)
			continue
		}

		if field.Type == "FlagSet" {
			rsFileData.AddImport("crate::pkm::types", "FlagSet")
		} else {
			switch rField.RustType {
			case "StatsPreSplit":
				rsFileData.AddImport("crate::pkm::types", "StatsPreSplit")
			case "Stats":
				rsFileData.AddImport("crate::pkm::types", "Stats")
			case "HyperTraining":
				rsFileData.AddImport("crate::pkm::types", "HyperTraining")
			case "ContestStats":
				rsFileData.AddImport("crate::pkm::types", "ContestStats")
			}
		}

		// Add necessary imports
		switch rField.Field.Name {
		case "trainer_gender":
			rsFileData.AddImport("crate::pkm::types", "Gender")
			// case "ribbons":
			// 	rsFileData.AddImport("../util/ribbonLogic", "filterRibbons")
			// 	for _, ribbonSpan := range rField.Field.RibbonSpans {
			// 		if ribbonSpan.ContestCounts {
			// 			if ribbonSpan.NumBits != 40 {
			// 				rsFileData.AddImport("../util/ribbonLogic", "gen3ContestRibbonsFromBuffer")
			// 				rsFileData.AddImport("../util/ribbonLogic", "gen3ContestRibbonsToBuffer")
			// 			} else {
			// 				rsFileData.AddImport("../util/ribbonLogic", "gen3ContestRibbonsFromBytes")
			// 				rsFileData.AddImport("../util/ribbonLogic", "gen3ContestRibbonsToBytes")
			// 			}
			// 		}
			// 		rsFileData.AddImport("pokemon-resources", ribbonListFromName(ribbonSpan.RibbonSet))
			// 	}
			// case "abilityIndex":
			// 	rsFileData.AddImport("pokemon-resources", "AbilityToString")
			// case "heldItemIndex":
			// 	if rsFileData.SchemaData.IsGen3 {
			// 		rsFileData.AddImport("pokemon-resources", "ItemGen3ToString")
			// 		rsFileData.AddImport("pokemon-resources", "ItemGen3FromString")
			// 	} else {
			// 		rsFileData.AddImport("pokemon-resources", "ItemToString")
			// 		rsFileData.AddImport("pokemon-resources", "ItemFromString")
			// 	}
			// case "nature":
			// 	rsFileData.AddImport("pokemon-resources", "NatureToString")
			// case "nickname", "trainerName":
			// 	if rField.Field.LengthCheck > 0 || rsFileData.IsGen3 {
			// 		rsFileData.AddImport("pokemon-species-data", "PokemonData")
			// 	}
			// case "ball":
			// 	rsFileData.AddImport("pokemon-resources", "Ball")
		}

		// if field.Conversion != nil {
		// 	rsFileData.AddDefaultImport("../conversion", "* as conversion")
		// }

		if rField.Field.ByteOffset != nil && *rField.Field.ByteOffset >= rsFileData.SchemaData.TotalBytes && field.LengthCheck == 0 {
			continue
		}

		rsFileData.Fields = append(rsFileData.Fields, *rField)
	}

	// Create the output file
	file, err := os.Create(fmt.Sprintf("rust/src/pkm/%s.rs", format))
	if err != nil {
		fmt.Println("Error creating output file:", err)
		return
	}
	defer file.Close()

	// isNotUniversal := func(fieldName string) bool {
	// 	return !universalFields[fieldName]
	// }

	// Create a template and execute it to generate the Go code
	tmpl := template.Must(template.New(format).Funcs(template.FuncMap{
		"fieldExists": fieldExists,
		// "fieldNullable":         isNotUniversal,
		// "setFieldFromOther":     setFieldFromOther,
		"commaJoinStrings":      commaJoinStrings,
		"getDecryptionFunction": getDecryptionFunction,
		"getUnshuffleFunction":  getUnshuffleFunction,
		"getShuffleFunction":    getShuffleFunction,
		"hexify":                hexify,
		"commaSeparateInts":     commaSeparate[int],
		"writeFieldToBytes":     writeFieldToBytes,
		"fieldValueFromBytes":   fieldValueFromBytes,
	}).Parse(rustClassTemplate))
	err = tmpl.Execute(file, rsFileData)
	if err != nil {
		fmt.Println("Error executing template:", err)
		return
	}

}
