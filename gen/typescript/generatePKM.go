package typescript

import (
	"encoding/json"
	"fmt"
	"os"
	"text/template"

	"github.com/andrewbenington/go-pokemon-files/gen/schema"
)

const typescriptClassTemplate = `// This file was generated by make generate


{{ $className := .SchemaData.FileName }} {{ $encoding := .SchemaData.StringEncoding}} {{ $endian := .SchemaData.Endian}} {{ $detectPrefix := .SchemaData.DetectPrefix}} {{ $schema := .SchemaData}} {{ $hasDecriptionCode := not (or $detectPrefix (eq (getDecryptionFunction $className) "")) }}

{{- range $file, $imports := .Imports }}
import { {{ commaJoinStrings $imports }} } from '{{ $file }}'
{{- end }}
{{- range $file, $imports := .DefaultImports }}
import {{ commaJoinStrings $imports }} from '{{ $file }}'
{{- end }}
import { getStats } from '../util/statCalc'
import * as byteLogic from '../util/byteLogic'
{{- if or (eq .SchemaData.StringEncoding "UTF-16") (eq .SchemaData.StringEncoding "Gen3") (eq .SchemaData.StringEncoding "GameBoy") (eq .SchemaData.StringEncoding "Gen5") (eq .SchemaData.StringEncoding "Gen4")}}
import * as stringLogic from '../util/stringConversion'
{{- end }}
import * as types from '../util/types'
{{- if $hasDecriptionCode }}
import * as encryption from '../util/encryption'
{{- end }}
{{- if .SchemaData.GenderFromPV}}
import { genderFromPID } from '../util/genderCalc'
{{- else if .SchemaData.GenderFromDVs}}
import { genderFromDVs } from '../util/genderCalc'
{{- end }}
import { AllPKMFields } from '../util/pkmInterface'
{{- if fieldExists .Fields "ivs"}}
import { getLevelGen3Onward } from '../util/statCalc'
{{- else if fieldExists .Fields "dvs"}}
import { getLevelGen12 } from '../util/statCalc'
{{- end }}
{{- if .SchemaData.IsGen3 }}
import { AbilityFromString } from 'pokemon-resources'
{{- end }}
{{- if eq .SchemaData.FileName "PK3" }}
import { getGen3MiscFlags } from '../util/util'
{{- end }}



export class {{ $className }} {
  static getName() {return '{{ $className }}'}
  format: '{{ $className }}' = '{{ $className }}'
{{- range .Fields }}
  {{ .Name }}: {{ .TypescriptType }}
{{- end }}

{{- if $hasDecriptionCode }}
  constructor(arg: ArrayBuffer | AllPKMFields, encrypted?: boolean) {
{{- else }}
  constructor(arg: ArrayBuffer | AllPKMFields) {
{{- end }}
    if (arg instanceof ArrayBuffer) {
      {{- if $detectPrefix }}
      const buffer = new Uint8Array(arg)[2] === 0xff ? arg.slice(3) : arg
      {{- else if eq (getDecryptionFunction $className) ""}}
      const buffer = arg
      {{- else }}
      let buffer = arg
      if (encrypted) {
        const unencryptedBytes = encryption.{{getDecryptionFunction $className}}(buffer)
        const unshuffledBytes = encryption.{{getUnshuffleFunction $className}}(unencryptedBytes)
        buffer = unshuffledBytes
      }
      {{- end }}
      const dataView = new DataView(buffer)
      {{- range $field := .Fields }}
        {{ setThisFieldFromBytes $field $schema }}
    {{- end }}
    } else {
      const other = arg
      {{- range $field := .Fields }}
        {{ setFieldFromOther $field $schema (fieldNullable $field.Name)}}
      {{- end }}
    }
  }

  static fromBytes(buffer: ArrayBuffer): {{ $className }} {
    return new {{ $className }}( buffer )
  }

  {{ if not (eq .SchemaData.TotalBytesExtraFields 0) }}
  toBytes(options?: types.ToBytesOptions): ArrayBuffer {
  {{ else }}
  toBytes(): ArrayBuffer {
  {{- end }}
    {{- if not (eq .SchemaData.TotalBytesExtraFields 0)}}
    const buffer = new ArrayBuffer(options?.includeExtraFields ? {{ .SchemaData.TotalBytesExtraFields }} : {{ .SchemaData.TotalBytes }});
    {{- else}}
    const buffer = new ArrayBuffer({{ .SchemaData.TotalBytes }});
    {{- end}}
    const dataView = new DataView(buffer)
    {{ range $field := .Fields }}
      {{- if not $field.NoWrite }}
        {{ writeFieldToBytes $field $schema }}
      {{- end }}
    {{- end }}
    {{- if eq .SchemaData.FileName "PK3" }}
    dataView.setUint8(0x13, getGen3MiscFlags(this))
    {{- end}}
    return buffer;
  }

  public getStats() {
    return getStats(this)
  }

{{- if .SchemaData.GenderFromPV}}

  public get gender() {
    return genderFromPID(this.personalityValue, this.dexNum)
  }

{{- else if .SchemaData.GenderFromDVs}}

  public get gender() {
    return genderFromDVs(this.dvs, this.dexNum)
  }

{{- end }}

{{- if fieldExists .Fields "languageIndex"}}

  public get language() {
    return Languages[this.languageIndex]
  }
{{- else }}

  public get language() {
    return Languages[0]
  }
{{- end }}

{{- if fieldExists .Fields "abilityIndex"}}

  public get abilityName() {
    return AbilityToString(this.abilityIndex)
  }
{{- end }}

{{- if fieldExists .Fields "heldItemIndex"}}

  {{- if .SchemaData.IsGen3 }}
  public get heldItemName() {
    return ItemGen3ToString(this.heldItemIndex)
  }

  {{- else }}
  public get heldItemName() {
    return ItemToString(this.heldItemIndex)
  }
  {{- end }}
{{- end }}

{{- if not (fieldExists .Fields "trainerGender")}}

  public get trainerGender() {
    return false
  }
{{- end }}

{{- if not (fieldExists .Fields "secretID")}}

  public get secretID() {
    return 0
  }
{{- end }}

{{- if not (fieldExists .Fields "gameOfOrigin")}}

  public get gameOfOrigin() {
    return 0
  }
{{- end }}

{{- if .SchemaData.NatureFromPV}}

  public get nature() {
    return this.personalityValue % 25
  }

{{- end }}

{{- if not (eq .SchemaData.PVAbilityBit nil)}}

  public get abilityNum() {
    return ((this.personalityValue >> {{.SchemaData.PVAbilityBit}}) & 1) + 1
  }

{{- end }}

{{- if .SchemaData.IsGen3 }}

  
  public get abilityIndex() {
    return AbilityFromString(this.ability)
  }

  public get ability() {
    const ability1 = PokemonData[this.dexNum]?.formes[0].ability1
    const ability2 = PokemonData[this.dexNum]?.formes[0].ability2
    if (this.abilityNum === 2 && ability2 && AbilityFromString(ability2) <= 77) {
      return ability2
    }
    return ability1
  }

{{- end }}

{{- if or .SchemaData.NatureFromPV (fieldExists .Fields "nature")}}

  public get natureName() {
    return NatureToString(this.nature)
  }
{{- end }}

{{- if .SchemaData.UnownFromIVs }}

  public get formeNum() {
    if (this.dexNum === NationalDex.Unown) {
      let ivCombinationVal = ((this.dvs.atk >> 1) & 0b11) << 6
      ivCombinationVal += ((this.dvs.def >> 1) & 0b11) << 4
      ivCombinationVal += ((this.dvs.spe >> 1) & 0b11) << 2
      ivCombinationVal += (this.dvs.spc >> 1) & 0b11
      ivCombinationVal /= 10
      return Math.floor(ivCombinationVal)
    }
    return 0
  }
{{- else if .SchemaData.UnownFromPV }}

  public get formeNum() {
    if (this.dexNum === NationalDex.Unown) {
      let letterValue = (this.personalityValue >> 24) & 0x3
      letterValue = ((this.personalityValue >> 16) & 0x3) | (letterValue << 2)
      letterValue = ((this.personalityValue >> 8) & 0x3) | (letterValue << 2)
      letterValue = (this.personalityValue & 0x3) | (letterValue << 2)
      return letterValue % 28
    }
    return 0
  }
{{- else if .SchemaData.NoFormes }}

  public get formeNum() {
    return 0
  }
{{- end }}


{{- if not (eq (getDecryptionFunction $className) "")}}
public refreshChecksum() {
  this.checksum = encryption.get16BitChecksumLittleEndian(this.toBytes(), {{- hexify .SchemaData.ChecksumStart }}, {{- hexify .SchemaData.ChecksumEnd }})
}

public toPCBytes() {
  const shuffledBytes = encryption.{{ getShuffleFunction $className }}(this.toBytes())
  return encryption.{{ getDecryptionFunction $className }}(shuffledBytes)
}

{{- end }}


{{- if fieldExists .Fields "ivs"}}
  public getLevel() {
    return getLevelGen3Onward(this.dexNum, this.exp)
  }
{{- else if fieldExists .Fields "dvs"}}
  public getLevel() {
    return getLevelGen12(this.dexNum, this.exp)
  }
{{- end }}

{{- if .SchemaData.ShinyFromDVs }}

  isShiny() {
    return (
      this.dvs.spe === 10 &&
      this.dvs.def === 10 &&
      this.dvs.spc === 10 &&
      [2, 3, 6, 7, 10, 11, 14, 15].includes(this.dvs.atk)
    )
  }

  isSquareShiny() {
    return false
  }

{{- else }}

  isShiny() {
    return (
      (this.trainerID ^
        this.secretID ^
        (this.personalityValue & 0xffff) ^
        ((this.personalityValue >> 16) & 0xffff)) <
      {{- .SchemaData.ShinyThreshold }}
    )
  }

  isSquareShiny() {
    return !(
      this.trainerID ^
      this.secretID ^
      (this.personalityValue & 0xffff) ^
      ((this.personalityValue >> 16) & 0xffff)
    )
  }

{{- end }}

  static maxValidMove() {
    return {{ .SchemaData.MaxValidMove }}
  }

  static maxValidBall() {
    return {{ .SchemaData.MaxBall }}
  }

  static allowedBalls() {
    return {{ commaSeparateInts .SchemaData.AllowedBalls }}
  }
}

export default {{ $className }}
`

func generateFormatClass(format string, universalFields map[string]bool) {
	// Read the content of the file
	data, err := os.ReadFile(fmt.Sprintf("src/schema/%s.json", format))
	if err != nil {
		fmt.Println("Error reading file:", err)
		return
	}

	tsFileData := TypeScriptSchemaData{
		SchemaData: schema.SchemaData{},
		Fields:     []TypeScriptField{},
	}
	tsFileData.AddImport("pokemon-resources", "Languages")
	tsFileData.AddImport("../util/util", "adjustMovePPBetweenFormats")

	json.Unmarshal(data, &tsFileData.SchemaData)

	if tsFileData.SchemaData.NatureFromPV {
		tsFileData.AddImport("pokemon-resources", "NatureToString")
	}
	if tsFileData.SchemaData.UnownFromIVs || tsFileData.SchemaData.UnownFromPV {
		tsFileData.AddImport("pokemon-species-data", "NationalDex")
	}
	if tsFileData.SchemaData.TrainerIDTracker {
		tsFileData.AddImport("pokemon-resources", "isGameBoy")
	}

	for _, field := range tsFileData.SchemaData.Fields {
		tField, err := TypeScriptFieldFromSchemaField(field)
		if err != nil {
			fmt.Printf("%s: skipping %s (%s)\n", format, field.Name, err)
			continue
		}

		// Add necessary imports
		switch tField.Field.Name {
		case "ribbons":
			tsFileData.AddImport("../util/ribbonLogic", "filterRibbons")
			for _, ribbonSpan := range tField.Field.RibbonSpans {
				if ribbonSpan.ContestCounts {
					if ribbonSpan.NumBits != 40 {
						tsFileData.AddImport("../util/ribbonLogic", "gen3ContestRibbonsFromBuffer")
						tsFileData.AddImport("../util/ribbonLogic", "gen3ContestRibbonsToBuffer")
					} else {
						tsFileData.AddImport("../util/ribbonLogic", "gen3ContestRibbonsFromBytes")
						tsFileData.AddImport("../util/ribbonLogic", "gen3ContestRibbonsToBytes")
					}
				}
				tsFileData.AddImport("pokemon-resources", ribbonListFromName(ribbonSpan.RibbonSet))
			}
		case "abilityIndex":
			tsFileData.AddImport("pokemon-resources", "AbilityToString")
		case "heldItemIndex":
			if tsFileData.SchemaData.IsGen3 {
				tsFileData.AddImport("pokemon-resources", "ItemGen3ToString")
				tsFileData.AddImport("pokemon-resources", "ItemGen3FromString")
			} else {
				tsFileData.AddImport("pokemon-resources", "ItemToString")
				tsFileData.AddImport("pokemon-resources", "ItemFromString")
			}
		case "nature":
			tsFileData.AddImport("pokemon-resources", "NatureToString")
		case "nickname", "trainerName":
			if tField.Field.LengthCheck > 0 || tsFileData.IsGen3 {
				tsFileData.AddImport("pokemon-species-data", "PokemonData")
			}
		case "ball":
			tsFileData.AddImport("pokemon-resources", "Ball")
		}

		if field.Conversion != nil {
			tsFileData.AddDefaultImport("../conversion", "* as conversion")
		}

		if tField.Field.ByteOffset != nil && *tField.Field.ByteOffset >= tsFileData.SchemaData.TotalBytes && field.LengthCheck == 0 {
			continue
		}

		tsFileData.Fields = append(tsFileData.Fields, *tField)
	}

	// Create the output file
	file, err := os.Create(fmt.Sprintf("src/pkm/%s.ts", format))
	if err != nil {
		fmt.Println("Error creating output file:", err)
		return
	}
	defer file.Close()

	isNotUniversal := func(fieldName string) bool {
		return !universalFields[fieldName]
	}

	// Create a template and execute it to generate the Go code
	tmpl := template.Must(template.New(format).Funcs(template.FuncMap{
		"fieldExists":           fieldExists,
		"fieldNullable":         isNotUniversal,
		"setFieldFromOther":     setFieldFromOther,
		"commaJoinStrings":      commaJoinStrings,
		"getDecryptionFunction": getDecryptionFunction,
		"getUnshuffleFunction":  getUnshuffleFunction,
		"getShuffleFunction":    getShuffleFunction,
		"hexify":                hexify,
		"commaSeparateInts":     commaSeparate[int],
		"writeFieldToBytes":     writeFieldToBytes,
		"setThisFieldFromBytes": setThisFieldFromBytes,
	}).Parse(typescriptClassTemplate))
	err = tmpl.Execute(file, tsFileData)
	if err != nil {
		fmt.Println("Error executing template:", err)
		return
	}

}
